require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const multer = require('multer');
const cors = require('cors');
const path = require('path');
const nodemailer = require('nodemailer');
const crypto = require('crypto');
const http = require('http');
const { Server } = require('socket.io');

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  cors: {
    origin: 'http://localhost:3000', // URL de votre frontend
    methods: ['GET', 'POST', 'DELETE', 'PUT'],
  },
});

app.use(cors());
app.use(express.json());
app.use('/uploads', express.static(path.join(__dirname, 'Uploads')));

// Connexion MongoDB
mongoose.connect(process.env.MONGODB_URI, {
  useNewUrlParser: true,
  useUnifiedTopology: true,
}).then(() => console.log('‚úÖ Connect√© √† MongoDB'))
  .catch(err => console.error('‚ùå Erreur MongoDB :', err.message));

// Sch√©ma utilisateur
const userSchema = new mongoose.Schema({
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  username: { type: String, default: '' },
  following: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
  isVerified: { type: Boolean, default: false },
  verificationToken: { type: String },
  verificationCode: { type: String },
  verificationCodeExpires: { type: Date },
});
const User = mongoose.model('User', userSchema);

// Sch√©ma m√©dia
const mediaSchema = new mongoose.Schema({
  filename: String,
  originalname: String,
  uploadedAt: { type: Date, default: Date.now },
  owner: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  likes: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
});
const Media = mongoose.model('Media', mediaSchema);

// Configuration Nodemailer
const transporter = nodemailer.createTransport({
  service: 'gmail',
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS,
  },
});

// JWT
const JWT_SECRET = process.env.JWT_SECRET;
const verifyToken = (req, res, next) => {
  const token = req.headers['authorization'];
  if (!token) return res.status(401).json({ message: 'Token requis' });
  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    req.user = decoded;
    next();
  } catch {
    res.status(403).json({ message: 'Token invalide' });
  }
};

// Multer config
const storage = multer.diskStorage({
  destination: 'Uploads/',
  filename: (req, file, cb) => {
    const unique = Date.now() + '-' + Math.round(Math.random() * 1e9);
    cb(null, unique + '-' + file.originalname);
  },
});
const upload = multer({ storage });

// G√©n√©rer un code de v√©rification √† 6 chiffres
const generateVerificationCode = () => {
  return Math.floor(100000 + Math.random() * 900000).toString();
};

// WebSocket : Gestion des connexions
io.on('connection', (socket) => {
  console.log('Un utilisateur est connect√© via WebSocket');
  socket.on('disconnect', () => {
    console.log('Utilisateur d√©connect√©');
  });
});

// Inscription
app.post('/register', async (req, res) => {
  const { email, password, username } = req.body;
  const existing = await User.findOne({ email });
  if (existing) return res.status(400).json({ message: 'Email d√©j√† utilis√©' });

  const usernameRegex = /^[a-zA-Z0-9_-]{3,20}$/;
  if (username && !usernameRegex.test(username)) {
    return res.status(400).json({ message: 'Nom d‚Äôutilisateur invalide (3-20 caract√®res, lettres, chiffres, -, _)' });
  }

  const hashed = await bcrypt.hash(password, 10);
  const verificationToken = crypto.randomBytes(32).toString('hex');
  const user = await User.create({
    email,
    password: hashed,
    username: username || email.split('@')[0],
    verificationToken,
  });

  const verificationLink = `http://localhost:5000/verify-email?token=${verificationToken}`;
  const mailOptions = {
    from: process.env.EMAIL_USER,
    to: email,
    subject: 'V√©rifiez votre adresse email - Pixels Media',
    html: `
      <h2>Bienvenue sur Pixels Media !</h2>
      <p>Veuillez v√©rifier votre adresse email en cliquant sur le lien suivant :</p>
      <a href="${verificationLink}">V√©rifier mon email</a>
      <p>Ce lien expire dans 24 heures.</p>
    `,
  };

  try {
    await transporter.sendMail(mailOptions);
    res.status(201).json({ message: 'Utilisateur inscrit. V√©rifiez votre email pour activer votre compte.' });
  } catch (error) {
    console.error('Erreur envoi email:', error);
    res.status(500).json({ message: 'Utilisateur inscrit, mais erreur lors de l‚Äôenvoi de l‚Äôemail de v√©rification.' });
  }
});

// Demander un nouveau code de v√©rification
app.post('/request-verification', verifyToken, async (req, res) => {
  try {
    const user = await User.findById(req.user.userId);
    if (!user) return res.status(404).json({ message: 'Utilisateur non trouv√©' });
    if (user.isVerified) return res.status(400).json({ message: 'Compte d√©j√† v√©rifi√©' });

    const verificationCode = generateVerificationCode();
    user.verificationCode = verificationCode;
    user.verificationCodeExpires = Date.now() + 15 * 60 * 1000;
    await user.save();

    const mailOptions = {
      from: process.env.EMAIL_USER,
      to: user.email,
      subject: 'Votre code de v√©rification - Pixels Media',
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: auto; padding: 20px; border: 1px solid #e0e0e0; border-radius: 10px; background-color: #f9f9f9;">
          <h2 style="color: #333;">V√©rification de votre compte Pixels Media</h2>
          <p style="color: #555;">Voici votre code de v√©rification :</p>
          <div style="text-align: center; padding: 15px; background-color: #007bff; color: white; font-size: 24px; font-weight: bold; border-radius: 5px; margin: 20px 0;">
            ${verificationCode}
          </div>
          <p style="color: #555;">Entrez ce code dans l'application pour v√©rifier votre compte. Ce code expire dans 15 minutes.</p>
        </div>
      `,
    };

    await transporter.sendMail(mailOptions);
    res.json({ message: 'Code de v√©rification envoy√© √† votre email.' });
  } catch (error) {
    console.error('Erreur /request-verification:', error);
    res.status(500).json({ message: 'Erreur lors de l‚Äôenvoi du code', error: error.message });
  }
});

// V√©rifier le code
app.post('/verify-code', verifyToken, async (req, res) => {
  const { code } = req.body;
  try {
    const user = await User.findById(req.user.userId);
    if (!user) return res.status(404).json({ message: 'Utilisateur non trouv√©' });
    if (user.isVerified) return res.status(400).json({ message: 'Compte d√©j√† v√©rifi√©' });
    if (!user.verificationCode || user.verificationCode !== code) {
      return res.status(400).json({ message: 'Code invalide' });
    }
    if (user.verificationCodeExpires < Date.now()) {
      return res.status(400).json({ message: 'Code expir√©. Demandez un nouveau code.' });
    }

    user.isVerified = true;
    user.verificationCode = undefined;
    user.verificationCodeExpires = undefined;
    user.verificationToken = undefined;
    await user.save();

    res.json({ message: 'Compte v√©rifi√© avec succ√®s.' });
  } catch (error) {
    console.error('Erreur /verify-code:', error);
    res.status(500).json({ message: 'Erreur serveur', error: error.message });
  }
});

// V√©rification email
app.get('/verify-email', async (req, res) => {
  const { token } = req.query;
  try {
    const user = await User.findOne({ verificationToken: token });
    if (!user) return res.status(400).json({ message: 'Lien de v√©rification invalide ou expir√©' });

    user.isVerified = true;
    user.verificationToken = undefined;
    user.verificationCode = undefined;
    user.verificationCodeExpires = undefined;
    await user.save();

    res.json({ message: 'Email v√©rifi√© avec succ√®s. Vous pouvez maintenant vous connecter.' });
  } catch (error) {
    console.error('Erreur /verify-email:', error);
    res.status(500).json({ message: 'Erreur serveur', error: error.message });
  }
});

// Connexion
app.post('/login', async (req, res) => {
  const { email, password } = req.body;
  const user = await User.findOne({ email });
  if (!user) return res.status(404).json({ message: 'Utilisateur non trouv√©' });
  if (!user.isVerified) return res.status(403).json({ message: 'Veuillez v√©rifier votre email avant de vous connecter' });

  const isValid = await bcrypt.compare(password, user.password);
  if (!isValid) return res.status(401).json({ message: 'Mot de passe incorrect' });

  const token = jwt.sign({ userId: user._id }, JWT_SECRET, { expiresIn: '2h' });
  res.json({ token, user: { email: user.email, username: user.username, isVerified: user.isVerified } });
});

// Profil utilisateur
app.get('/profile', verifyToken, async (req, res) => {
  try {
    const user = await User.findById(req.user.userId).select('email username isVerified');
    if (!user) return res.status(404).json({ message: 'Utilisateur non trouv√©' });
    res.json({ email: user.email, username: user.username, isVerified: user.isVerified });
  } catch (error) {
    console.error('Erreur /profile:', error);
    res.status(500).json({ message: 'Erreur serveur', error: error.message });
  }
});

// Mettre √† jour le profil
app.put('/profile', verifyToken, async (req, res) => {
  const { username } = req.body;
  if (!username || !username.trim()) {
    return res.status(400).json({ message: 'Le nom d‚Äôutilisateur ne peut pas √™tre vide' });
  }

  const usernameRegex = /^[a-zA-Z0-9_-]{3,20}$/;
  if (!usernameRegex.test(username)) {
    return res.status(400).json({ message: 'Nom d‚Äôutilisateur invalide (3-20 caract√®res, lettres, chiffres, -, _)' });
  }

  try {
    const user = await User.findByIdAndUpdate(
      req.user.userId,
      { username: username.trim() },
      { new: true, runValidators: true }
    ).select('email username isVerified');
    if (!user) return res.status(404).json({ message: 'Utilisateur non trouv√©' });
    res.json({ message: 'Profil mis √† jour', user: { email: user.email, username: user.username, isVerified: user.isVerified } });
  } catch (error) {
    console.error('Erreur /profile PUT:', error);
    res.status(500).json({ message: 'Erreur serveur', error: error.message });
  }
});

// Upload m√©dia
app.post('/upload', verifyToken, upload.single('media'), async (req, res) => {
  if (!req.file) return res.status(400).json({ message: 'Aucun fichier' });
  try {
    const user = await User.findById(req.user.userId);
    if (!user.isVerified) return res.status(403).json({ message: 'Veuillez v√©rifier votre email avant d‚Äôuploader des fichiers' });

    const media = await Media.create({
      filename: req.file.filename,
      originalname: req.file.originalname,
      owner: req.user.userId,
      likes: [],
    });
    res.status(201).json({ message: 'Fichier upload√©', media });
    // √âmettre un √©v√©nement WebSocket pour les nouveaux m√©dias
    io.emit('newMedia', { media, owner: user });
  } catch (error) {
    console.error('Erreur /upload:', error);
    res.status(500).json({ message: 'Erreur serveur', error: error.message });
  }
});

// Feed des m√©dias des abonn√©s
app.get('/feed', verifyToken, async (req, res) => {
  try {
    const user = await User.findById(req.user.userId);
    if (!user) return res.status(404).json({ message: 'Utilisateur non trouv√©' });
    const medias = await Media.find({ owner: { $in: user.following || [] } })
      .populate('owner', 'email username')
      .sort({ uploadedAt: -1 });
    const mediasWithLikes = medias.map(media => ({
      ...media._doc,
      likesCount: media.likes.length,
      isLiked: media.likes.includes(req.user.userId),
    }));
    res.json(mediasWithLikes || []);
  } catch (error) {
    console.error('Erreur /feed:', error);
    res.status(500).json({ message: 'Erreur serveur', error: error.message });
  }
});

// Liste des utilisateurs
app.get('/users', verifyToken, async (req, res) => {
  try {
    const q = req.query.q || '';
    const users = await User.find({
      $or: [
        { email: { $regex: q, $options: 'i' } },
        { username: { $regex: q, $options: 'i' } },
      ],
      _id: { $ne: req.user.userId },
    }).select('email username');
    res.json(users || []);
  } catch (error) {
    console.error('Erreur /users:', error);
    res.status(500).json({ message: 'Erreur serveur', error: error.message });
  }
});

// Liste des followings
app.get('/follows', verifyToken, async (req, res) => {
  try {
    const user = await User.findById(req.user.userId).populate('following', 'email username');
    res.json(user.following || []);
  } catch (error) {
    console.error('Erreur /follows:', error);
    res.status(500).json({ message: 'Erreur serveur', error: error.message });
  }
});

// Suivre un utilisateur
app.post('/follow', verifyToken, async (req, res) => {
  const { followingId } = req.body;
  try {
    const user = await User.findById(req.user.userId);
    if (!user.isVerified) return res.status(403).json({ message: 'Veuillez v√©rifier votre email avant de suivre des utilisateurs' });

    await User.findByIdAndUpdate(req.user.userId, { $addToSet: { following: followingId } });
    res.json({ message: 'Abonnement effectu√©' });
    // √âmettre un √©v√©nement WebSocket
    io.emit('followUpdate', { userId: req.user.userId, followingId });
  } catch (error) {
    console.error('Erreur /follow:', error);
    res.status(500).json({ message: 'Erreur serveur', error: error.message });
  }
});

// Ne plus suivre
app.delete('/follow', verifyToken, async (req, res) => {
  const { followingId } = req.body;
  try {
    await User.findByIdAndUpdate(req.user.userId, { $pull: { following: followingId } });
    res.json({ message: 'D√©sabonnement effectu√©' });
    // √âmettre un √©v√©nement WebSocket
    io.emit('unfollowUpdate', { userId: req.user.userId, unfollowedId: followingId });
  } catch (error) {
    console.error('Erreur /follow DELETE:', error);
    res.status(500).json({ message: 'Erreur serveur', error: error.message });
  }
});

// R√©cup√©rer ses propres m√©dias
app.get('/my-medias', verifyToken, async (req, res) => {
  try {
    const list = await Media.find({ owner: req.user.userId })
      .sort({ uploadedAt: -1 })
      .select('-likes');
    res.json(list || []);
  } catch (error) {
    console.error('Erreur /my-medias:', error);
    res.status(500).json({ message: 'Erreur serveur', error: error.message });
  }
});

// Modifier le nom d‚Äôun fichier
app.put('/media/:id', verifyToken, async (req, res) => {
  try {
    const media = await Media.findById(req.params.id);
    if (!media || media.owner.toString() !== req.user.userId)
      return res.status(403).json({ message: 'Non autoris√©' });
    media.originalname = req.body.originalname;
    await media.save();
    res.json({ message: 'Nom mis √† jour', media });
  } catch (error) {
    console.error('Erreur /media/:id PUT:', error);
    res.status(500).json({ message: 'Erreur serveur', error: error.message });
  }
});

// Supprimer un fichier
app.delete('/media/:id', verifyToken, async (req, res) => {
  try {
    const media = await Media.findById(req.params.id);
    if (!media || media.owner.toString() !== req.user.userId)
      return res.status(403).json({ message: 'Non autoris√©' });
    await media.deleteOne();
    res.json({ message: 'Fichier supprim√©' });
    // √âmettre un √©v√©nement WebSocket
    io.emit('mediaDeleted', { mediaId: req.params.id });
  } catch (error) {
    console.error('Erreur /media/:id DELETE:', error);
    res.status(500).json({ message: 'Erreur serveur', error: error.message });
  }
});

// Ajouter un like
app.post('/like/:mediaId', verifyToken, async (req, res) => {
  try {
    const user = await User.findById(req.user.userId);
    if (!user.isVerified) return res.status(403).json({ message: 'Veuillez v√©rifier votre email avant d‚Äôaimer un m√©dia' });

    const media = await Media.findById(req.params.mediaId);
    if (!media) return res.status(404).json({ message: 'M√©dia non trouv√©' });

    if (media.likes.includes(req.user.userId)) {
      return res.status(400).json({ message: 'M√©dia d√©j√† aim√©' });
    }

    media.likes.push(req.user.userId);
    await media.save();
    res.json({ message: 'M√©dia aim√©', likesCount: media.likes.length });
    // √âmettre un √©v√©nement WebSocket
    io.emit('likeUpdate', { mediaId: req.params.mediaId, likesCount: media.likes.length, userId: req.user.userId });
  } catch (error) {
    console.error('Erreur /like/:mediaId POST:', error);
    res.status(500).json({ message: 'Erreur serveur', error: error.message });
  }
});

// Retirer un like
app.delete('/like/:mediaId', verifyToken, async (req, res) => {
  try {
    const media = await Media.findById(req.params.mediaId);
    if (!media) return res.status(404).json({ message: 'M√©dia non trouv√©' });

    if (!media.likes.includes(req.user.userId)) {
      return res.status(400).json({ message: 'M√©dia non aim√©' });
    }

    media.likes = media.likes.filter(userId => userId.toString() !== req.user.userId.toString());
    await media.save();
    res.json({ message: 'Like retir√©', likesCount: media.likes.length });
    // √âmettre un √©v√©nement WebSocket
    io.emit('unlikeUpdate', { mediaId: req.params.mediaId, likesCount: media.likes.length, userId: req.user.userId });
  } catch (error) {
    console.error('Erreur /like/:mediaId DELETE:', error);
    res.status(500).json({ message: 'Erreur serveur', error: error.message });
  }
});

// Lancement serveur
const PORT = process.env.PORT || 5000;
server.listen(PORT, () => console.log(`üöÄ Serveur actif sur http://localhost:${PORT}`));
